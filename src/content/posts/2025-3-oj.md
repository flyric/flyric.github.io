---
title: 第一个后端项目
published: 2024-03-10
description: 蒟蒻的第一个Golang 项目
tags: [Golang,HTML,CSS,JavaScript,MYSQL]
category: 后端开发
draft: false
---
### 一个很菜的 Go OJ 项目记录（新手向）

最近用 Go 写了一个非常基础、也比较垃圾的在线判题系统（OJ）。
功能不完整，安全性也不行，架构更谈不上优雅，但对我个人来说，它算是一次**把 Go 后端、并发和 Web 流程串起来的练习**。

项目地址：

[![GitHub](https://img.shields.io/badge/GitHub-Repo-black?logo=github)](https://github.com/MoScenix/Go-OJ)


这篇文章主要是 **自我记录**，不是什么教程，也不推荐直接照着写生产项目。

---

### 项目简介

这是一个简单的在线判题系统（OJ），用于提交编程题目、查看判题结果和管理用户账号。后端使用 Go 语言开发，前端使用 HTML、CSS 和 JavaScript 进行设计。

### 一、为什么要写这个项目？

原因很简单：

* 学了点 Go
* 看了很多 OJ / 后端相关的东西
* 但一直停留在“看懂”，没真正做过完整系统

于是就想着：

> 能不能写一个 **从登录 → 提交代码 → 判题 → 返回结果** 的最小 OJ？

哪怕写得很烂，只要能跑通。

---

### 二、项目整体情况

这个项目：

* ❌ **不安全**
* ❌ **不适合生产**
* ❌ 判题没有沙箱
* ❌ 架构耦合严重
* ❌ 代码也不算好看

它唯一的优点可能是：

> **我一个新手，真的把它从 0 写出来了。**

---

### 三、使用的技术栈（都很基础）

#### 后端

* Go
* `net/http` 写 Web 服务
* Goroutine + Channel 处理并发
* `context.Context` 传递请求信息
* `uuid` 用作 Session 标识

#### 前端

* 原生 HTML / CSS / JS
* 没有框架，页面很丑，但能用

#### 数据层

* MySQL
* 只做了最基础的存储

---

### 四、用户系统（非常基础）

#### 1️⃣ Session 使用 


登录成功后，服务端会生成一个 **UUID** 作为 Session，用来标识用户状态。
这个直接设置的十年，不会失效。

---

#### 2️⃣ 密码自动加密存储

用户密码 **不会明文存储**：

* 注册时：密码 → Hash → 存数据库
* 登录时：输入密码 → Hash → 对比

使用的是 Go 常见的 Hash。

---

### 五、判题系统是怎么写的

#### 生产者–消费者模型

大致逻辑是：

* 用户提交代码 → 生成判题任务
* 任务丢进 Channel
* 后台启动多个 Goroutine 判题

这是 Goroutine 很经典的用法，新手也比较容易理解。

---
#### 使用 Context（明显的坑）

在当前实现中，判题流程**使用了 Go 的 `context.Context`** 来控制并发测试用例的执行流程，例如：

* 控制并发用例之间的取消
* 在某个用例失败时中断其余测试
* 管理一次判题任务内部的生命周期

这些 `context` **并非直接来自 HTTP 请求的 `r.Context()`**，而是在判题逻辑内部通过 `context.Background()` 创建，用于简化并发控制。

当时选择这种方式的原因很简单：

> 好用、好传，不用额外设计判题任务结构

但现在回头看，这种做法仍然存在明显问题：

* `context` 被当成了流程控制的“万能工具”，承担了过多职责

需要强调的是，`context` 本身**并不是问题**，问题在于它**只提供流程控制能力**，并不具备任何安全隔离或资源限制能力，却被用于驱动判题这一高风险逻辑。

如果是在真实的 OJ 或生产环境中，这种设计是**不可接受的**。

---

### 六、安全性：几乎没有

这个 OJ 项目的安全性几乎为 0，主要体现在：

* 判题代码直接以宿主机进程的形式运行，没有任何沙箱隔离
* 未对用户程序的 CPU、内存、输出规模等资源进行有效限制
* 用户提交的代码理论上可以执行任意恶意或异常行为
* 判题逻辑与 Web 服务运行在同一进程、同一台机器上，资源完全共享

即使引入了 `context`、超时控制或并发限制，它们也只能**尽量中断流程**，并不能真正防止资源被滥用，更无法保证系统整体稳定性。

因此，这个实现只能作为**学习和实验用途**，而不是一个可以部署到生产环境的在线判题系统。

---

### 七、这个项目我学到了什么？

比起“学会了什么技术”，我觉得更重要的是：

#### 把零散知识串起来了

* HTTP
* Session
* 并发
* 简单任务调度

#### 可能更新：

* 判题沙箱（Docker / nsjail）
* 服务拆分
* 更合理的任务队列
* 安全边界设计

---

**把一个“完整后端系统”从 0 写到能用**

刚学 Go，刚接触后端，其实写这种“并不完美”的项目，比一直看教程要有用得多。

等哪天我水平高了，再回头看这份代码，大概只会想删库跑路（*

---
